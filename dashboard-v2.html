<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' blob: data:; script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net; style-src 'self' 'unsafe-inline'; connect-src 'self' https://api.anthropic.com; img-src 'self' data: blob:;">
    <title>STAGE Performance Marketing Dashboard v2.0</title>

    <!-- CDN Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dexie@3.2.4/dist/dexie.min.js"></script>

    <style>
        /* ========== CSS (Same as before with additions) ========== */
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --primary: #2563eb; --primary-dark: #1e40af; --success: #10b981;
            --danger: #ef4444; --warning: #f59e0b; --gray-50: #f9fafb;
            --gray-100: #f3f4f6; --gray-200: #e5e7eb; --gray-300: #d1d5db;
            --gray-600: #4b5563; --gray-700: #374151; --gray-800: #1f2937;
            --gray-900: #111827;
            --font-sans: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            --spacing-xs: 0.25rem; --spacing-sm: 0.5rem; --spacing-md: 1rem;
            --spacing-lg: 1.5rem; --spacing-xl: 2rem;
            --radius-sm: 0.375rem; --radius-md: 0.5rem; --radius-lg: 0.75rem;
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1);
        }

        body { font-family: var(--font-sans); background-color: var(--gray-50); color: var(--gray-900); line-height: 1.5; }
        .container { max-width: 1400px; margin: 0 auto; padding: var(--spacing-lg); }

        /* Header */
        .header { background: white; border-bottom: 2px solid var(--gray-200); padding: var(--spacing-lg) 0; margin-bottom: var(--spacing-xl); box-shadow: var(--shadow-sm); }
        .header-content { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: var(--spacing-md); }
        .header h1 { font-size: 1.875rem; font-weight: 700; color: var(--primary); }
        .header-subtitle { font-size: 0.875rem; color: var(--gray-600); margin-top: var(--spacing-xs); }

        /* Market Selector */
        .market-selector { display: flex; gap: var(--spacing-sm); background: var(--gray-100); padding: var(--spacing-xs); border-radius: var(--radius-lg); }
        .market-btn { padding: var(--spacing-sm) var(--spacing-lg); border: none; background: transparent; color: var(--gray-700); font-weight: 500; cursor: pointer; border-radius: var(--radius-md); transition: all 0.2s; }
        .market-btn:hover { background: white; }
        .market-btn.active { background: var(--primary); color: white; box-shadow: var(--shadow-md); }

        /* Upload Section */
        .upload-section { background: white; border-radius: var(--radius-lg); padding: var(--spacing-xl); margin-bottom: var(--spacing-xl); box-shadow: var(--shadow-md); }
        .upload-zone { border: 2px dashed var(--gray-300); border-radius: var(--radius-lg); padding: var(--spacing-xl); text-align: center; cursor: pointer; transition: all 0.2s; }
        .upload-zone:hover, .upload-zone.drag-over { border-color: var(--primary); background: var(--gray-50); }
        .upload-icon { font-size: 3rem; margin-bottom: var(--spacing-md); }
        .upload-text { font-size: 1.125rem; font-weight: 500; color: var(--gray-700); margin-bottom: var(--spacing-sm); }
        .upload-hint { font-size: 0.875rem; color: var(--gray-600); }
        .progress-bar { width: 100%; height: 8px; background: var(--gray-200); border-radius: var(--radius-sm); overflow: hidden; margin-top: var(--spacing-md); display: none; }
        .progress-bar.active { display: block; }
        .progress-fill { height: 100%; background: var(--primary); transition: width 0.3s; width: 0%; }

        /* Tab Navigation */
        .tab-nav { display: flex; gap: var(--spacing-sm); margin-bottom: var(--spacing-xl); overflow-x: auto; border-bottom: 2px solid var(--gray-200); }
        .tab-btn { padding: var(--spacing-md) var(--spacing-lg); border: none; background: transparent; color: var(--gray-600); font-weight: 500; cursor: pointer; border-bottom: 3px solid transparent; transition: all 0.2s; white-space: nowrap; }
        .tab-btn:hover { color: var(--primary); }
        .tab-btn.active { color: var(--primary); border-bottom-color: var(--primary); }

        /* KPI Cards */
        .kpi-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: var(--spacing-lg); margin-bottom: var(--spacing-xl); }
        .kpi-card { background: white; border-radius: var(--radius-lg); padding: var(--spacing-lg); box-shadow: var(--shadow-md); border-left: 4px solid var(--gray-300); transition: transform 0.2s; }
        .kpi-card:hover { transform: translateY(-2px); box-shadow: var(--shadow-lg); }
        .kpi-card.healthy { border-left-color: var(--success); }
        .kpi-card.unhealthy { border-left-color: var(--danger); }
        .kpi-label { font-size: 0.875rem; color: var(--gray-600); font-weight: 500; margin-bottom: var(--spacing-sm); }
        .kpi-value { font-size: 2rem; font-weight: 700; color: var(--gray-900); margin-bottom: var(--spacing-xs); }
        .kpi-indicator { display: inline-flex; align-items: center; gap: var(--spacing-xs); font-size: 0.875rem; font-weight: 600; }
        .kpi-indicator.healthy { color: var(--success); }
        .kpi-indicator.unhealthy { color: var(--danger); }
        .kpi-trend { display: inline-flex; align-items: center; gap: var(--spacing-xs); font-size: 0.75rem; margin-top: var(--spacing-xs); color: var(--gray-600); }

        /* Chart & Insights Sections */
        .chart-section, .insights-section { background: white; border-radius: var(--radius-lg); padding: var(--spacing-xl); margin-bottom: var(--spacing-xl); box-shadow: var(--shadow-md); }
        .chart-title, .section-title { font-size: 1.25rem; font-weight: 600; color: var(--gray-900); margin-bottom: var(--spacing-lg); }
        .chart-container { position: relative; height: 400px; margin-bottom: var(--spacing-lg); }

        /* Show Table */
        .show-table { width: 100%; border-collapse: collapse; margin-top: var(--spacing-md); }
        .show-table th, .show-table td { padding: var(--spacing-md); text-align: left; border-bottom: 1px solid var(--gray-200); }
        .show-table th { background: var(--gray-50); font-weight: 600; color: var(--gray-700); }
        .show-table tr:hover { background: var(--gray-50); }
        .show-table .top-performer { background: #ecfdf5; font-weight: 600; }
        .show-table .underperformer { background: #fef2f2; }

        /* Insights */
        .insight-card { background: var(--gray-50); border-left: 4px solid var(--primary); padding: var(--spacing-lg); border-radius: var(--radius-md); margin-bottom: var(--spacing-md); }
        .insight-card.high { border-left-color: var(--danger); }
        .insight-card.medium { border-left-color: var(--warning); }
        .insight-card.low { border-left-color: var(--success); }
        .insight-title { font-weight: 600; font-size: 1.125rem; margin-bottom: var(--spacing-sm); }
        .insight-analysis { color: var(--gray-700); margin-bottom: var(--spacing-sm); line-height: 1.6; }
        .insight-recommendation { background: white; padding: var(--spacing-md); border-radius: var(--radius-sm); margin-top: var(--spacing-sm); }
        .insight-badge { display: inline-block; padding: 0.25rem 0.75rem; border-radius: var(--radius-sm); font-size: 0.75rem; font-weight: 600; margin-bottom: var(--spacing-sm); }
        .insight-badge.high { background: #fee2e2; color: var(--danger); }
        .insight-badge.medium { background: #fef3c7; color: var(--warning); }
        .insight-badge.low { background: #d1fae5; color: var(--success); }

        /* Settings */
        .settings-btn { background: var(--gray-200); padding: var(--spacing-sm) var(--spacing-md); border-radius: var(--radius-md); border: none; cursor: pointer; font-weight: 500; }
        .settings-btn:hover { background: var(--gray-300); }

        /* Tab Content */
        .tab-content { display: none; }
        .tab-content.active { display: block; }

        /* Utilities */
        .hidden { display: none !important; }
        .loading { text-align: center; padding: var(--spacing-xl); color: var(--gray-600); }
        .error-message { background: #fef2f2; border: 1px solid var(--danger); color: var(--danger); padding: var(--spacing-md); border-radius: var(--radius-md); margin-bottom: var(--spacing-md); }
        .empty-state { text-align: center; padding: calc(var(--spacing-xl) * 2); color: var(--gray-600); }
        .empty-state-icon { font-size: 4rem; margin-bottom: var(--spacing-md); opacity: 0.3; }

        /* Comparison Grid */
        .comparison-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: var(--spacing-lg); }
        .comparison-card { background: white; border: 2px solid var(--gray-200); border-radius: var(--radius-lg); padding: var(--spacing-lg); }
        .comparison-card h4 { font-size: 1.125rem; margin-bottom: var(--spacing-md); color: var(--primary); }

        /* Responsive */
        @media (max-width: 768px) {
            .container { padding: var(--spacing-md); }
            .header h1 { font-size: 1.5rem; }
            .kpi-grid { grid-template-columns: 1fr; }
            .market-selector { flex-wrap: wrap; }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <div class="container">
            <div class="header-content">
                <div>
                    <h1>üìä STAGE Performance Marketing Dashboard v2.0</h1>
                    <div class="header-subtitle">Multi-Market Analytics with AI Insights</div>
                </div>
                <div style="display: flex; gap: 1rem; align-items: center;">
                    <button class="settings-btn" onclick="showSettings()">‚öôÔ∏è Settings</button>
                    <div class="market-selector">
                        <button class="market-btn active" data-market="gujarati">Gujarati</button>
                        <button class="market-btn" data-market="haryanvi">Haryanvi</button>
                        <button class="market-btn" data-market="rajasthani">Rajasthani</button>
                        <button class="market-btn" data-market="bhojpuri">Bhojpuri</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Container -->
    <div class="container">
        <!-- Upload Section -->
        <div class="upload-section">
            <div class="upload-zone" id="uploadZone">
                <div class="upload-icon">üì§</div>
                <div class="upload-text">Drag & Drop Excel Files Here</div>
                <div class="upload-hint">or click to browse (supports .xlsx, .csv) - Upload 5-10 files at once</div>
                <input type="file" id="fileInput" multiple accept=".xlsx,.xls,.csv" style="display: none;">
            </div>
            <div class="progress-bar" id="progressBar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
        </div>

        <!-- Tab Navigation -->
        <div class="tab-nav">
            <button class="tab-btn active" data-tab="overall">üìà Overall Performance</button>
            <button class="tab-btn" data-tab="channel">üéØ Channel Analysis</button>
            <button class="tab-btn" data-tab="platform">üíª Platform Breakdown</button>
            <button class="tab-btn" data-tab="show">üé¨ Show Performance</button>
            <button class="tab-btn" data-tab="insights">ü§ñ AI Insights</button>
            <button class="tab-btn" data-tab="compare">üîÑ Market Comparison</button>
        </div>

        <!-- Tab: Overall Performance -->
        <div class="tab-content active" id="tab-overall">
            <div class="kpi-grid" id="kpiGrid"></div>
            <div class="chart-section">
                <h3 class="chart-title">Performance Trends (Week-over-Week)</h3>
                <div class="chart-container">
                    <canvas id="trendsChart"></canvas>
                </div>
            </div>
            <div class="empty-state" id="emptyState">
                <div class="empty-state-icon">üìä</div>
                <h3>No Data Available</h3>
                <p>Upload Excel files to see performance metrics</p>
            </div>
        </div>

        <!-- Tab: Channel Analysis -->
        <div class="tab-content" id="tab-channel">
            <div class="chart-section">
                <h3 class="chart-title">Meta vs Google Performance Comparison</h3>
                <div class="chart-container">
                    <canvas id="channelChart"></canvas>
                </div>
            </div>
        </div>

        <!-- Tab: Platform Breakdown -->
        <div class="tab-content" id="tab-platform">
            <div class="chart-section">
                <h3 class="chart-title">App vs Web Performance Analysis</h3>
                <div class="chart-container">
                    <canvas id="platformChart"></canvas>
                </div>
            </div>
        </div>

        <!-- Tab: Show Performance -->
        <div class="tab-content" id="tab-show">
            <div class="chart-section">
                <h3 class="chart-title">Show-wise Performance Analysis</h3>
                <div id="showTableContainer"></div>
            </div>
        </div>

        <!-- Tab: AI Insights -->
        <div class="tab-content" id="tab-insights">
            <div class="insights-section">
                <h3 class="section-title">ü§ñ AI-Powered Strategic Insights</h3>
                <div id="insightsContainer">
                    <div class="loading">Loading insights...</div>
                </div>
                <button class="settings-btn" onclick="generateInsights()" style="margin-top: 1rem;">üîÑ Regenerate Insights</button>
            </div>
        </div>

        <!-- Tab: Market Comparison -->
        <div class="tab-content" id="tab-compare">
            <div class="chart-section">
                <h3 class="chart-title">Cross-Market Performance Comparison</h3>
                <div class="comparison-grid" id="comparisonGrid"></div>
            </div>
        </div>
    </div>

    <script>
        // ========== CONFIGURATION ==========
        const CONFIG = {
            markets: ['gujarati', 'haryanvi', 'rajasthani', 'bhojpuri'],
            thresholds: { CTR: 0.75, IR: 10, TR: 20, TCR: 30, CAC: 250 },
            metaColumns: { spend: 'Spends_GST', trials: 'af_start_trial', cac: 'Mandate_CAC', ir: 'AF_IR%', tr: 'TR%_AF', tcr: 'TCR_D0', ctr: 'CTR%' },
            googleColumns: { spend: 'Spends_GST', trials: 'start_trial_d0', cac: 'CP_AF_CPT_D0', ir: 'AF_IR%', tr: 'AF_TR%', tcr: 'AF_TCR%', ctr: 'CTR%' }
        };

        // ========== DATABASE ==========
        const db = new Dexie('STAGEDashboard');
        db.version(1).stores({
            markets: 'name, data, insights, updatedAt',
            history: '++id, market, weekStart, weekEnd, data, createdAt',
            settings: 'key, value',
            cache: 'key, value, expiresAt'
        });

        // ========== STATE MANAGER ==========
        class StateManager {
            constructor() {
                this.state = {
                    currentMarket: 'gujarati',
                    currentTab: 'overall',
                    markets: { gujarati: null, haryanvi: null, rajasthani: null, bhojpuri: null },
                    uploadProgress: 0,
                    apiKey: null
                };
                this.listeners = [];
            }
            subscribe(listener) {
                this.listeners.push(listener);
                return () => { this.listeners = this.listeners.filter(l => l !== listener); };
            }
            setState(path, value) {
                const keys = path.split('.');
                let current = this.state;
                for (let i = 0; i < keys.length - 1; i++) current = current[keys[i]];
                current[keys[keys.length - 1]] = value;
                this.notify();
            }
            getState(path) {
                if (!path) return this.state;
                const keys = path.split('.');
                let current = this.state;
                for (const key of keys) {
                    current = current[key];
                    if (current === undefined) return undefined;
                }
                return current;
            }
            notify() { this.listeners.forEach(listener => listener(this.state)); }
        }
        const stateManager = new StateManager();

        // ========== ANALYTICS ENGINE ==========
        class AnalyticsEngine {
            static calculateOverall(data) {
                if (!data || !data.length) return null;
                let totalSpend = 0, totalTrials = 0, irSum = 0, trSum = 0, tcrSum = 0, ctrSum = 0, count = 0;
                data.forEach(row => {
                    totalSpend += parseFloat(row.spend) || 0;
                    totalTrials += parseInt(row.trials) || 0;
                    irSum += parseFloat(row.ir) || 0;
                    trSum += parseFloat(row.tr) || 0;
                    tcrSum += parseFloat(row.tcr) || 0;
                    ctrSum += parseFloat(row.ctr) || 0;
                    count++;
                });
                const cac = totalTrials > 0 ? totalSpend / totalTrials : 0;
                return {
                    totalSpend: totalSpend.toFixed(0),
                    totalTrials,
                    cac: cac.toFixed(2),
                    ir: (irSum / count).toFixed(2),
                    tr: (trSum / count).toFixed(2),
                    tcr: (tcrSum / count).toFixed(2),
                    ctr: (ctrSum / count).toFixed(2)
                };
            }

            static calculateChannelBreakdown(data) {
                const meta = data.filter(d => d.channel === 'meta');
                const google = data.filter(d => d.channel === 'google');
                return { meta: this.calculateOverall(meta), google: this.calculateOverall(google) };
            }

            static calculatePlatformBreakdown(data) {
                const app = data.filter(d => d.platform === 'app');
                const web = data.filter(d => d.platform === 'web');
                return { app: this.calculateOverall(app), web: this.calculateOverall(web) };
            }

            static calculateShowPerformance(data) {
                const showMap = {};
                data.forEach(row => {
                    if (!showMap[row.show]) showMap[row.show] = [];
                    showMap[row.show].push(row);
                });
                return Object.keys(showMap).map(show => ({
                    show,
                    ...this.calculateOverall(showMap[show])
                })).sort((a, b) => b.totalTrials - a.totalTrials);
            }

            static checkThreshold(metric, value) {
                value = parseFloat(value);
                switch(metric) {
                    case 'CTR': return value > CONFIG.thresholds.CTR;
                    case 'IR': return value >= CONFIG.thresholds.IR;
                    case 'TR': return value >= CONFIG.thresholds.TR;
                    case 'TCR': return value < CONFIG.thresholds.TCR;
                    case 'CAC': return value < CONFIG.thresholds.CAC;
                    default: return true;
                }
            }

            static formatCurrency(value) {
                return '‚Çπ' + parseFloat(value).toLocaleString('en-IN');
            }

            static formatPercentage(value) {
                return parseFloat(value).toFixed(2) + '%';
            }
        }

        // ========== UPLOAD HANDLER ==========
        class UploadHandler {
            constructor() { this.setupEventListeners(); }

            setupEventListeners() {
                const uploadZone = document.getElementById('uploadZone');
                const fileInput = document.getElementById('fileInput');
                uploadZone.addEventListener('click', () => fileInput.click());
                uploadZone.addEventListener('dragover', (e) => { e.preventDefault(); uploadZone.classList.add('drag-over'); });
                uploadZone.addEventListener('dragleave', () => uploadZone.classList.remove('drag-over'));
                uploadZone.addEventListener('drop', (e) => { e.preventDefault(); uploadZone.classList.remove('drag-over'); this.handleFiles(e.dataTransfer.files); });
                fileInput.addEventListener('change', (e) => this.handleFiles(e.target.files));
            }

            async handleFiles(files) {
                if (!files.length) return;
                const progressBar = document.getElementById('progressBar');
                const progressFill = document.getElementById('progressFill');
                progressBar.classList.add('active');

                try {
                    const parsedData = [];
                    for (let i = 0; i < files.length; i++) {
                        progressFill.style.width = ((i / files.length) * 100) + '%';
                        const data = await this.parseExcelFile(files[i]);
                        if (data) parsedData.push(...data);
                    }
                    progressFill.style.width = '100%';

                    const currentMarket = stateManager.getState('currentMarket');

                    // Store historical snapshot
                    await db.history.add({
                        market: currentMarket,
                        weekStart: new Date().toISOString().split('T')[0],
                        weekEnd: new Date(Date.now() + 7*24*60*60*1000).toISOString().split('T')[0],
                        data: parsedData,
                        createdAt: new Date().toISOString()
                    });

                    await db.markets.put({
                        name: currentMarket,
                        data: parsedData,
                        insights: null,
                        updatedAt: new Date().toISOString()
                    });

                    stateManager.setState(`markets.${currentMarket}`, parsedData);
                    DashboardRenderer.render();

                    setTimeout(() => {
                        progressBar.classList.remove('active');
                        progressFill.style.width = '0%';
                    }, 1000);
                } catch (error) {
                    console.error('Error processing files:', error);
                    alert('Error processing files: ' + error.message);
                    progressBar.classList.remove('active');
                }
            }

            async parseExcelFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const data = new Uint8Array(e.target.result);
                            const workbook = XLSX.read(data, { type: 'array' });
                            const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                            const jsonData = XLSX.utils.sheet_to_json(firstSheet);
                            const normalized = this.normalizeData(jsonData);
                            resolve(normalized);
                        } catch (error) { reject(error); }
                    };
                    reader.onerror = () => reject(new Error('Failed to read file'));
                    reader.readAsArrayBuffer(file);
                });
            }

            normalizeData(data) {
                const firstRow = data[0];
                const isMeta = 'af_start_trial' in firstRow;
                return data.map(row => {
                    const cols = isMeta ? CONFIG.metaColumns : CONFIG.googleColumns;
                    return {
                        channel: isMeta ? 'meta' : 'google',
                        platform: this.detectPlatform(row),
                        show: row.Show || row.show || 'Unknown',
                        spend: parseFloat(row[cols.spend]) || 0,
                        trials: parseInt(row[cols.trials]) || 0,
                        cac: parseFloat(row[cols.cac]) || 0,
                        ir: parseFloat(row[cols.ir]) || 0,
                        tr: parseFloat(row[cols.tr]) || 0,
                        tcr: parseFloat(row[cols.tcr]) || 0,
                        ctr: parseFloat(row[cols.ctr]) || 0
                    };
                }).filter(row => row !== null);
            }

            detectPlatform(row) {
                const str = JSON.stringify(row).toLowerCase();
                if (str.includes('web')) return 'web';
                if (str.includes('app')) return 'app';
                return 'app';
            }
        }

        // ========== DASHBOARD RENDERER ==========
        class DashboardRenderer {
            static render() {
                const currentMarket = stateManager.getState('currentMarket');
                const data = stateManager.getState(`markets.${currentMarket}`);

                if (!data || !data.length) {
                    document.getElementById('emptyState').classList.remove('hidden');
                    document.getElementById('kpiGrid').innerHTML = '';
                    return;
                }

                document.getElementById('emptyState').classList.add('hidden');
                const metrics = AnalyticsEngine.calculateOverall(data);
                if (metrics) this.renderKPICards(metrics);

                // Render charts based on active tab
                const currentTab = stateManager.getState('currentTab');
                if (currentTab === 'channel') this.renderChannelChart(data);
                if (currentTab === 'platform') this.renderPlatformChart(data);
                if (currentTab === 'show') this.renderShowTable(data);
                if (currentTab === 'overall') this.renderTrendsChart();
                if (currentTab === 'compare') this.renderComparison();
            }

            static renderKPICards(metrics) {
                const kpis = [
                    { label: 'Total Spend', value: AnalyticsEngine.formatCurrency(metrics.totalSpend), metric: 'SPEND', threshold: true },
                    { label: 'Total Trials', value: metrics.totalTrials.toLocaleString(), metric: 'TRIALS', threshold: true },
                    { label: 'Average CAC', value: AnalyticsEngine.formatCurrency(metrics.cac), metric: 'CAC', threshold: AnalyticsEngine.checkThreshold('CAC', metrics.cac) },
                    { label: 'CTR (Click Through Rate)', value: AnalyticsEngine.formatPercentage(metrics.ctr), metric: 'CTR', threshold: AnalyticsEngine.checkThreshold('CTR', metrics.ctr) },
                    { label: 'IR (Install Rate)', value: AnalyticsEngine.formatPercentage(metrics.ir), metric: 'IR', threshold: AnalyticsEngine.checkThreshold('IR', metrics.ir) },
                    { label: 'TR (Trial Rate)', value: AnalyticsEngine.formatPercentage(metrics.tr), metric: 'TR', threshold: AnalyticsEngine.checkThreshold('TR', metrics.tr) },
                    { label: 'D0 TCR (Trial Churn Rate)', value: AnalyticsEngine.formatPercentage(metrics.tcr), metric: 'TCR', threshold: AnalyticsEngine.checkThreshold('TCR', metrics.tcr) }
                ];

                document.getElementById('kpiGrid').innerHTML = kpis.map(kpi => `
                    <div class="kpi-card ${kpi.threshold ? 'healthy' : 'unhealthy'}">
                        <div class="kpi-label">${kpi.label}</div>
                        <div class="kpi-value">${kpi.value}</div>
                        <div class="kpi-indicator ${kpi.threshold ? 'healthy' : 'unhealthy'}">
                            ${kpi.threshold ? '‚úÖ Healthy' : '‚ùå Needs Attention'}
                        </div>
                    </div>
                `).join('');
            }

            static renderChannelChart(data) {
                const breakdown = AnalyticsEngine.calculateChannelBreakdown(data);
                const ctx = document.getElementById('channelChart');
                if (!ctx) return;

                if (window.channelChartInstance) window.channelChartInstance.destroy();

                window.channelChartInstance = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: ['Spend (‚Çπ)', 'Trials', 'CAC (‚Çπ)', 'CTR %', 'IR %', 'TR %', 'TCR %'],
                        datasets: [
                            { label: 'Meta', data: [breakdown.meta?.totalSpend, breakdown.meta?.totalTrials, breakdown.meta?.cac, breakdown.meta?.ctr, breakdown.meta?.ir, breakdown.meta?.tr, breakdown.meta?.tcr], backgroundColor: 'rgba(59, 130, 246, 0.7)' },
                            { label: 'Google', data: [breakdown.google?.totalSpend, breakdown.google?.totalTrials, breakdown.google?.cac, breakdown.google?.ctr, breakdown.google?.ir, breakdown.google?.tr, breakdown.google?.tcr], backgroundColor: 'rgba(16, 185, 129, 0.7)' }
                        ]
                    },
                    options: { responsive: true, maintainAspectRatio: false }
                });
            }

            static renderPlatformChart(data) {
                const breakdown = AnalyticsEngine.calculatePlatformBreakdown(data);
                const ctx = document.getElementById('platformChart');
                if (!ctx) return;

                if (window.platformChartInstance) window.platformChartInstance.destroy();

                window.platformChartInstance = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: ['Spend (‚Çπ)', 'Trials', 'CAC (‚Çπ)', 'CTR %', 'IR %', 'TR %', 'TCR %'],
                        datasets: [
                            { label: 'App', data: [breakdown.app?.totalSpend, breakdown.app?.totalTrials, breakdown.app?.cac, breakdown.app?.ctr, breakdown.app?.ir, breakdown.app?.tr, breakdown.app?.tcr], backgroundColor: 'rgba(139, 92, 246, 0.7)' },
                            { label: 'Web', data: [breakdown.web?.totalSpend, breakdown.web?.totalTrials, breakdown.web?.cac, breakdown.web?.ctr, breakdown.web?.ir, breakdown.web?.tr, breakdown.web?.tcr], backgroundColor: 'rgba(245, 158, 11, 0.7)' }
                        ]
                    },
                    options: { responsive: true, maintainAspectRatio: false }
                });
            }

            static renderShowTable(data) {
                const shows = AnalyticsEngine.calculateShowPerformance(data);
                const container = document.getElementById('showTableContainer');

                container.innerHTML = `
                    <table class="show-table">
                        <thead>
                            <tr>
                                <th>Show Name</th>
                                <th>Spend (‚Çπ)</th>
                                <th>Trials</th>
                                <th>CAC (‚Çπ)</th>
                                <th>CTR %</th>
                                <th>IR %</th>
                                <th>TR %</th>
                                <th>TCR %</th>
                                <th>Status</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${shows.map((show, idx) => {
                                const rowClass = idx < 3 ? 'top-performer' : (parseFloat(show.tcr) > 30 || parseFloat(show.cac) > 250) ? 'underperformer' : '';
                                return `
                                    <tr class="${rowClass}">
                                        <td><strong>${show.show}</strong></td>
                                        <td>${AnalyticsEngine.formatCurrency(show.totalSpend)}</td>
                                        <td>${show.totalTrials.toLocaleString()}</td>
                                        <td>${AnalyticsEngine.formatCurrency(show.cac)}</td>
                                        <td>${show.ctr}%</td>
                                        <td>${show.ir}%</td>
                                        <td>${show.tr}%</td>
                                        <td>${show.tcr}%</td>
                                        <td>${idx < 3 ? 'üèÜ Top Performer' : (rowClass === 'underperformer' ? '‚ö†Ô∏è Needs Attention' : '‚úÖ Good')}</td>
                                    </tr>
                                `;
                            }).join('')}
                        </tbody>
                    </table>
                `;
            }

            static async renderTrendsChart() {
                const currentMarket = stateManager.getState('currentMarket');
                const history = await db.history.where('market').equals(currentMarket).sortBy('createdAt');

                if (history.length < 2) return; // Need at least 2 weeks for trends

                const ctx = document.getElementById('trendsChart');
                if (!ctx) return;

                if (window.trendsChartInstance) window.trendsChartInstance.destroy();

                const labels = history.map((h, i) => `Week ${i + 1}`);
                const cacData = history.map(h => {
                    const metrics = AnalyticsEngine.calculateOverall(h.data);
                    return metrics ? parseFloat(metrics.cac) : 0;
                });
                const trialsData = history.map(h => {
                    const metrics = AnalyticsEngine.calculateOverall(h.data);
                    return metrics ? metrics.totalTrials : 0;
                });

                window.trendsChartInstance = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels,
                        datasets: [
                            { label: 'CAC (‚Çπ)', data: cacData, borderColor: 'rgba(239, 68, 68, 1)', tension: 0.4, yAxisID: 'y' },
                            { label: 'Trials', data: trialsData, borderColor: 'rgba(16, 185, 129, 1)', tension: 0.4, yAxisID: 'y1' }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: { type: 'linear', position: 'left', title: { display: true, text: 'CAC (‚Çπ)' } },
                            y1: { type: 'linear', position: 'right', title: { display: true, text: 'Trials' }, grid: { drawOnChartArea: false } }
                        }
                    }
                });
            }

            static async renderComparison() {
                const container = document.getElementById('comparisonGrid');
                const markets = CONFIG.markets;
                const comparisonData = [];

                for (const market of markets) {
                    const marketData = await db.markets.get(market);
                    if (marketData && marketData.data) {
                        const metrics = AnalyticsEngine.calculateOverall(marketData.data);
                        comparisonData.push({ market, metrics });
                    }
                }

                container.innerHTML = comparisonData.map(item => `
                    <div class="comparison-card">
                        <h4>${item.market.charAt(0).toUpperCase() + item.market.slice(1)}</h4>
                        <p><strong>Total Spend:</strong> ${AnalyticsEngine.formatCurrency(item.metrics.totalSpend)}</p>
                        <p><strong>Total Trials:</strong> ${item.metrics.totalTrials.toLocaleString()}</p>
                        <p><strong>CAC:</strong> ${AnalyticsEngine.formatCurrency(item.metrics.cac)}</p>
                        <p><strong>TCR:</strong> ${item.metrics.tcr}%</p>
                    </div>
                `).join('');
            }
        }

        // ========== EXECUTIVE INSIGHTS ENGINE (No API Required) ==========
        async function generateInsights() {
            const currentMarket = stateManager.getState('currentMarket');
            const data = stateManager.getState(`markets.${currentMarket}`);

            if (!data || !data.length) {
                alert('Please upload data first');
                return;
            }

            const container = document.getElementById('insightsContainer');
            container.innerHTML = '<div class="loading">Analyzing performance data...</div>';

            // Calculate comprehensive metrics
            const metrics = AnalyticsEngine.calculateOverall(data);
            const shows = AnalyticsEngine.calculateShowPerformance(data);
            const channelBreakdown = AnalyticsEngine.calculateChannelBreakdown(data);
            const platformBreakdown = AnalyticsEngine.calculatePlatformBreakdown(data);

            // Get historical data for WoW comparison
            const history = await db.history.where('market').equals(currentMarket).sortBy('createdAt');
            const hasHistory = history.length >= 2;
            let wowTrends = null;
            if (hasHistory) {
                const previousWeek = history[history.length - 2];
                const previousMetrics = AnalyticsEngine.calculateOverall(previousWeek.data);
                wowTrends = {
                    cacChange: ((parseFloat(metrics.cac) - parseFloat(previousMetrics.cac)) / parseFloat(previousMetrics.cac) * 100).toFixed(1),
                    trialsChange: ((metrics.totalTrials - previousMetrics.totalTrials) / previousMetrics.totalTrials * 100).toFixed(1),
                    spendChange: ((parseFloat(metrics.totalSpend) - parseFloat(previousMetrics.totalSpend)) / parseFloat(previousMetrics.totalSpend) * 100).toFixed(1),
                    tcrChange: ((parseFloat(metrics.tcr) - parseFloat(previousMetrics.tcr)) / parseFloat(previousMetrics.tcr) * 100).toFixed(1)
                };
            }

            const insights = [];

            // === INSIGHT 1: Portfolio Performance Analysis ===
            const topShow = shows[0];
            const top3Shows = shows.slice(0, 3);
            const top3Volume = top3Shows.reduce((sum, s) => sum + parseInt(s.totalTrials), 0);
            const top3VolumePercent = (top3Volume / metrics.totalTrials * 100).toFixed(1);
            const top3Spend = top3Shows.reduce((sum, s) => sum + parseFloat(s.totalSpend), 0);
            const top3SpendPercent = (top3Spend / parseFloat(metrics.totalSpend) * 100).toFixed(1);

            const portfolioConcentration = top3VolumePercent > 70 ? 'high' : top3VolumePercent > 50 ? 'moderate' : 'balanced';
            const concentrationRisk = portfolioConcentration === 'high' ? 'Consider diversifying to reduce dependency' :
                                      portfolioConcentration === 'moderate' ? 'Good balance between scale and diversification' :
                                      'Well-diversified portfolio with multiple revenue streams';

            insights.push({
                title: `üìä Portfolio Analysis: ${top3VolumePercent}% Revenue Concentration in Top 3 Shows`,
                analysis: `<strong>${topShow.show}</strong> leads with ${topShow.totalTrials.toLocaleString()} trials (${((topShow.totalTrials/metrics.totalTrials)*100).toFixed(1)}% of volume) at ‚Çπ${topShow.cac} CAC. Top 3 shows (${top3Shows.map(s => s.show).join(', ')}) drive <strong>${top3VolumePercent}%</strong> of trials while consuming <strong>${top3SpendPercent}%</strong> of budget${top3SpendPercent < top3VolumePercent ? ' ‚Äî indicating superior efficiency' : ''}. Portfolio concentration is <strong>${portfolioConcentration}</strong>. ${concentrationRisk}.`,
                recommendation: `<strong>Strategic Action:</strong> ${portfolioConcentration === 'high' ? `Reduce risk by scaling 2-3 mid-tier shows with CAC <‚Çπ280. Allocate 15% of ${topShow.show}'s budget to test new titles. Target: Increase 4th-10th ranked shows to represent 20% of volume within 3 weeks.` : `Continue current portfolio mix. Scale ${topShow.show} by 15-20% while maintaining 25% budget for show diversification. Monitor weekly to prevent over-concentration.`}`,
                priority: portfolioConcentration === 'high' ? 'high' : 'medium',
                impact: `Potential to unlock ${Math.floor(metrics.totalTrials * 0.15).toLocaleString()} additional trials through optimization`
            });

            // === INSIGHT 2: CAC Efficiency & Scaling Opportunity ===
            const efficientShows = shows.filter(s => parseFloat(s.cac) < 250 && parseInt(s.totalTrials) > 100);
            const inefficientShows = shows.filter(s => parseFloat(s.cac) >= 250);
            const avgEfficientCAC = efficientShows.length > 0 ?
                (efficientShows.reduce((sum, s) => sum + parseFloat(s.cac), 0) / efficientShows.length).toFixed(2) : metrics.cac;

            const scalingPotential = efficientShows.reduce((sum, s) => sum + parseInt(s.totalTrials), 0);
            const potentialTrialIncrease = Math.floor(scalingPotential * 0.25); // 25% scale assumption
            const incrementalSpend = potentialTrialIncrease * avgEfficientCAC;

            const cacStatus = parseFloat(metrics.cac) < 250 ? '‚úÖ below target' : '‚ö†Ô∏è above target';
            const wowCacTrend = wowTrends ? (parseFloat(wowTrends.cacChange) < 0 ? `‚Üì improving by ${Math.abs(wowTrends.cacChange)}%` : `‚Üë worsening by ${wowTrends.cacChange}%`) : '';

            insights.push({
                title: `üí∞ CAC Efficiency Analysis: ‚Çπ${metrics.cac} ${cacStatus}${wowTrends ? ' (' + wowCacTrend + ' WoW)' : ''}`,
                analysis: `Current blended CAC of <strong>‚Çπ${metrics.cac}</strong> vs ‚Çπ250 target. <strong>${efficientShows.length} of ${shows.length} shows</strong> operating below target CAC, driving ${((scalingPotential/metrics.totalTrials)*100).toFixed(1)}% of volume at avg ‚Çπ${avgEfficientCAC} CAC. ${inefficientShows.length > 0 ? `<strong>${inefficientShows.length} shows</strong> exceed CAC target (${inefficientShows.map(s => `${s.show}: ‚Çπ${s.cac}`).join(', ')}), requiring immediate optimization or budget reallocation.` : 'All shows performing efficiently.'}`,
                recommendation: `<strong>Immediate Action:</strong> ${efficientShows.length > 0 ? `<strong>SCALE WINNERS:</strong> Increase budget 20-25% for: ${efficientShows.slice(0,3).map(s => `${s.show} (current: ‚Çπ${(parseFloat(s.totalSpend)/100000).toFixed(1)}L, target: ‚Çπ${(parseFloat(s.totalSpend)*1.25/100000).toFixed(1)}L)`).join('; ')}. Expected outcome: +${potentialTrialIncrease.toLocaleString()} trials for ‚Çπ${(incrementalSpend/100000).toFixed(2)}L incremental spend.` : ''} ${inefficientShows.length > 0 ? `<strong>FIX/PAUSE UNDERPERFORMERS:</strong> Reduce spend 30-50% on ${inefficientShows.slice(0,2).map(s => s.show).join(', ')} until CAC improves to <‚Çπ280. Reallocate ‚Çπ${((inefficientShows.reduce((s,sh)=>s+parseFloat(sh.totalSpend),0)*0.4)/100000).toFixed(1)}L to efficient shows.` : ''}`,
                priority: parseFloat(metrics.cac) > 250 ? 'high' : efficientShows.length >= 3 ? 'high' : 'medium',
                impact: `ROI optimization: ${potentialTrialIncrease.toLocaleString()} incremental trials at ‚Çπ${avgEfficientCAC} CAC = ${((potentialTrialIncrease * avgEfficientCAC)/100000).toFixed(1)}L efficient spend`
            });

            // === INSIGHT 3: Retention Crisis or Opportunity ===
            const healthyTCRShows = shows.filter(s => parseFloat(s.tcr) < 30);
            const poorTCRShows = shows.filter(s => parseFloat(s.tcr) >= 30);
            const bestTCRShow = shows.reduce((best, s) => parseFloat(s.tcr) < parseFloat(best.tcr) ? s : best, shows[0]);
            const worstTCRShow = shows.reduce((worst, s) => parseFloat(s.tcr) > parseFloat(worst.tcr) ? s : worst, shows[0]);
            const tcrGap = (parseFloat(worstTCRShow.tcr) - parseFloat(bestTCRShow.tcr)).toFixed(1);

            const lostTrials = poorTCRShows.reduce((sum, s) => {
                const excessChurn = (parseFloat(s.tcr) - 29) / 100;
                return sum + Math.floor(parseInt(s.totalTrials) * excessChurn);
            }, 0);

            const tcrStatus = parseFloat(metrics.tcr) < 30 ? '‚úÖ Healthy' : 'üö® CRITICAL';
            const tcrTrend = wowTrends ? (parseFloat(wowTrends.tcrChange) < 0 ? `improving ‚Üì${Math.abs(wowTrends.tcrChange)}%` : `worsening ‚Üë${wowTrends.tcrChange}%`) : '';

            insights.push({
                title: `${parseFloat(metrics.tcr) >= 30 ? 'üö®' : '‚úÖ'} Trial Retention Analysis: ${metrics.tcr}% TCR ${tcrStatus}${wowTrends ? ' (' + tcrTrend + ')' : ''}`,
                analysis: `Overall D0 trial churn at <strong>${metrics.tcr}%</strong> vs <30% target. Performance range: <strong>${bestTCRShow.tcr}%</strong> (${bestTCRShow.show}) to <strong>${worstTCRShow.tcr}%</strong> (${worstTCRShow.show}) = ${tcrGap}% variance. ${healthyTCRShows.length} shows meet retention target${healthyTCRShows.length > 0 ? ` (${healthyTCRShows.slice(0,3).map(s => `${s.show}: ${s.tcr}%`).join(', ')})` : ''}. ${poorTCRShows.length > 0 ? `<strong style="color: var(--danger);">${poorTCRShows.length} shows</strong> exceed 30% churn, bleeding approximately <strong>${lostTrials.toLocaleString()} trials</strong> (‚Çπ${((lostTrials * parseFloat(metrics.cac))/100000).toFixed(1)}L wasted spend).` : 'All shows demonstrating strong retention.'}`,
                recommendation: `<strong>Root Cause Analysis Required:</strong> ${parseFloat(metrics.tcr) >= 30 ? `<strong>URGENT:</strong> Retention crisis costing ‚Çπ${((lostTrials * parseFloat(metrics.cac))/100000).toFixed(1)}L/week. Benchmark ${bestTCRShow.show} (${bestTCRShow.tcr}% TCR) against worst performers. Audit: (1) Content quality ${poorTCRShows.map(s=>s.show).join('/')}, (2) Onboarding UX, (3) Trial value proposition, (4) Genre targeting mismatch. Implement learnings from ${bestTCRShow.show} within 48 hours.` : `Maintain current retention excellence. Document success factors from ${healthyTCRShows.slice(0,2).map(s=>s.show).join(' & ')} (avg ${(healthyTCRShows.slice(0,2).reduce((s,sh)=>s+parseFloat(sh.tcr),0)/2).toFixed(1)}% TCR) and replicate across portfolio.`} Target: Reduce blended TCR to <28% = +${Math.floor(metrics.totalTrials * 0.02).toLocaleString()} retained trials.`,
                priority: parseFloat(metrics.tcr) >= 35 ? 'high' : parseFloat(metrics.tcr) >= 30 ? 'high' : 'medium',
                impact: `Fixing retention = ${lostTrials.toLocaleString()} trial recovery = ‚Çπ${((lostTrials * parseFloat(metrics.cac))/100000).toFixed(1)}L cost avoidance`
            });

            // === INSIGHT 4: Channel & Platform Strategy ===
            const metaPerf = channelBreakdown.meta;
            const googlePerf = channelBreakdown.google;
            const appPerf = platformBreakdown.app;
            const webPerf = platformBreakdown.web;

            const channelLeader = !metaPerf || !googlePerf ? null :
                parseFloat(metaPerf.cac) < parseFloat(googlePerf.cac) ? 'Meta' : 'Google';
            const platformLeader = !appPerf || !webPerf ? null :
                parseFloat(appPerf.cac) < parseFloat(webPerf.cac) ? 'App' : 'Web';

            if (metaPerf && googlePerf) {
                const cacDiff = Math.abs(parseFloat(metaPerf.cac) - parseFloat(googlePerf.cac)).toFixed(0);
                const cacDiffPercent = (cacDiff / Math.min(parseFloat(metaPerf.cac), parseFloat(googlePerf.cac)) * 100).toFixed(0);
                const metaShare = (parseInt(metaPerf.totalTrials) / metrics.totalTrials * 100).toFixed(0);
                const googleShare = (parseInt(googlePerf.totalTrials) / metrics.totalTrials * 100).toFixed(0);

                insights.push({
                    title: `üéØ Channel Mix Optimization: ${channelLeader} Outperforming by ‚Çπ${cacDiff} CAC (${cacDiffPercent}%)`,
                    analysis: `<strong>Meta:</strong> ${metaPerf.totalTrials.toLocaleString()} trials @ ‚Çπ${metaPerf.cac} CAC (${metaShare}% share). <strong>Google:</strong> ${googlePerf.totalTrials.toLocaleString()} trials @ ‚Çπ${googlePerf.cac} CAC (${googleShare}% share). ${channelLeader} demonstrates <strong>‚Çπ${cacDiff} lower CAC</strong> (+${cacDiffPercent}% efficiency edge). Current budget allocation: Meta ‚Çπ${(parseFloat(metaPerf.totalSpend)/100000).toFixed(1)}L, Google ‚Çπ${(parseFloat(googlePerf.totalSpend)/100000).toFixed(1)}L.`,
                    recommendation: `<strong>Budget Rebalancing:</strong> ${channelLeader === 'Meta' ? `Increase Meta budget 15-20% (from ‚Çπ${(parseFloat(metaPerf.totalSpend)/100000).toFixed(1)}L to ‚Çπ${(parseFloat(metaPerf.totalSpend)*1.2/100000).toFixed(1)}L). ${cacDiffPercent > 20 ? `Consider reducing Google spend 10-15% and reallocating to Meta until Google CAC improves.` : `Maintain Google at current levels for audience diversity.`}` : `Scale Google campaigns 15-20%. ${cacDiffPercent > 20 ? `Audit Meta targeting and creative fatigue.` : `Maintain balanced mix for platform diversification.`}`} Target blended CAC: ‚Çπ${(parseFloat(metrics.cac) * 0.93).toFixed(0)} (-7% optimization).`,
                    priority: cacDiffPercent > 20 ? 'high' : 'medium',
                    impact: `Channel optimization = ${Math.floor(parseFloat(metrics.totalSpend)/Math.min(parseFloat(metaPerf.cac), parseFloat(googlePerf.cac))-metrics.totalTrials).toLocaleString()} incremental trials at same budget`
                });
            }

            // === INSIGHT 5: Funnel Performance ===
            const funnelHealth = {
                ctr: { value: parseFloat(metrics.ctr), target: 0.75, status: parseFloat(metrics.ctr) > 0.75 ? '‚úÖ' : '‚ö†Ô∏è' },
                ir: { value: parseFloat(metrics.ir), target: 10, status: parseFloat(metrics.ir) >= 10 ? '‚úÖ' : '‚ö†Ô∏è' },
                tr: { value: parseFloat(metrics.tr), target: 20, status: parseFloat(metrics.tr) >= 20 ? '‚úÖ' : '‚ö†Ô∏è' }
            };

            const passedThresholds = [funnelHealth.ctr, funnelHealth.ir, funnelHealth.tr].filter(m => m.status === '‚úÖ').length;
            const funnelScore = `${passedThresholds}/3 thresholds passed`;

            const bottleneck = funnelHealth.ctr.status === '‚ö†Ô∏è' ? 'Creative/Targeting (CTR)' :
                              funnelHealth.ir.status === '‚ö†Ô∏è' ? 'App Store Conversion (IR)' :
                              funnelHealth.tr.status === '‚ö†Ô∏è' ? 'Trial Conversion (TR)' : 'None';

            if (bottleneck !== 'None') {
                insights.push({
                    title: `‚ö†Ô∏è Funnel Bottleneck Detected: ${bottleneck} Underperforming`,
                    analysis: `Funnel health: <strong>${funnelScore}</strong>. CTR ${funnelHealth.ctr.status} ${metrics.ctr}% (target: >0.75%), IR ${funnelHealth.ir.status} ${metrics.ir}% (target: ‚â•10%), TR ${funnelHealth.tr.status} ${metrics.tr}% (target: ‚â•20%). Primary bottleneck: <strong>${bottleneck}</strong> constraining overall conversion. Every 1% improvement at bottleneck stage = +${Math.floor(metrics.totalTrials * 0.01 * (bottleneck === 'Creative/Targeting (CTR)' ? 10 : bottleneck === 'App Store Conversion (IR)' ? 5 : 2)).toLocaleString()} trials.`,
                    recommendation: `<strong>Funnel Optimization Priority:</strong> ${
                        bottleneck === 'Creative/Targeting (CTR)' ? `CTR at ${metrics.ctr}% indicates ad creative fatigue or poor targeting. Action: (1) A/B test 3 new creative variants this week, (2) Audit audience targeting - expand lookalikes by 1%, (3) Rotate creatives every 5-7 days. Target: CTR >1.0% = +${Math.floor((1.0 - parseFloat(metrics.ctr)) * parseFloat(metrics.totalSpend) / parseFloat(metrics.cac)).toLocaleString()} trials.` :
                        bottleneck === 'App Store Conversion (IR)' ? `IR at ${metrics.ir}% suggests app store listing optimization needed. Action: (1) A/B test new app screenshots highlighting show heroes, (2) Optimize first 50 characters of description, (3) Feature social proof (ratings/reviews). Target: IR 12% = +${Math.floor((12 - parseFloat(metrics.ir)) / 100 * parseFloat(metrics.totalSpend) / parseFloat(metrics.cac) * 5).toLocaleString()} trials.` :
                        `TR at ${metrics.tr}% indicates value prop mismatch. Action: (1) Simplify trial signup (reduce steps), (2) Highlight exclusive content immediately, (3) Optimize paywall timing. Target: TR 23% = +${Math.floor((23 - parseFloat(metrics.tr)) / 100 * metrics.totalTrials).toLocaleString()} trials.`
                    }`,
                    priority: 'high',
                    impact: `Fixing bottleneck = ${Math.floor(metrics.totalTrials * 0.15).toLocaleString()} trial uplift potential`
                });
            }

            // === INSIGHT 6: Week-over-Week Momentum ===
            if (wowTrends) {
                const momentum = parseFloat(wowTrends.trialsChange) > 0 ? 'positive' : 'negative';
                const accelerating = parseFloat(wowTrends.cacChange) < 0 && parseFloat(wowTrends.trialsChange) > 0;

                insights.push({
                    title: `üìà Growth Momentum: ${momentum === 'positive' ? '‚Üë' : '‚Üì'} ${Math.abs(wowTrends.trialsChange)}% Trial ${momentum === 'positive' ? 'Growth' : 'Decline'} WoW`,
                    analysis: `Week-over-week trends: Trials ${wowTrends.trialsChange > 0 ? '‚Üë' : '‚Üì'}<strong>${Math.abs(wowTrends.trialsChange)}%</strong> (${wowTrends.trialsChange > 0 ? '+' : ''}${Math.floor(metrics.totalTrials * parseFloat(wowTrends.trialsChange) / (100 + parseFloat(wowTrends.trialsChange))).toLocaleString()} trials), Spend ${wowTrends.spendChange > 0 ? '‚Üë' : '‚Üì'}<strong>${Math.abs(wowTrends.spendChange)}%</strong>, CAC ${wowTrends.cacChange > 0 ? '‚Üë' : '‚Üì'}<strong>${Math.abs(wowTrends.cacChange)}%</strong>, TCR ${wowTrends.tcrChange > 0 ? '‚Üë' : '‚Üì'}<strong>${Math.abs(wowTrends.tcrChange)}%</strong>. ${accelerating ? 'üî• <strong>Positive acceleration:</strong> Growing trials with improving CAC indicates scalable efficiency.' : momentum === 'positive' ? 'Growth trajectory established.' : '‚ö†Ô∏è <strong>Negative momentum:</strong> Declining performance requires immediate intervention.'}`,
                    recommendation: `<strong>${momentum === 'positive' ? 'Capitalize on Momentum' : 'Reverse Negative Trend'}:</strong> ${
                        accelerating ? `Exceptional performance - scale aggressively. Increase weekly budget by 25% while maintaining current mix. Prepare for 2x scale by securing additional content inventory and optimizing fulfillment for +${Math.floor(metrics.totalTrials * 0.25).toLocaleString()} trials next week.` :
                        momentum === 'positive' && parseFloat(wowTrends.cacChange) > 0 ? `Growing trials but CAC rising (${wowTrends.cacChange}%) suggests diminishing returns. Pause budget increases, optimize current campaigns, test new audiences before next scale.` :
                        `<strong>CRITICAL:</strong> ${Math.abs(wowTrends.trialsChange)}% decline requires root cause analysis. Audit: (1) Creative fatigue, (2) Seasonal factors, (3) Competitive activity, (4) Platform algorithm changes. Implement corrective actions within 48h to reverse trend before Week 3.`
                    }`,
                    priority: momentum === 'negative' ? 'high' : accelerating ? 'high' : 'medium',
                    impact: momentum === 'positive' ? `Sustaining growth trajectory = ${Math.floor(metrics.totalTrials * (1 + parseFloat(wowTrends.trialsChange)/100) * 1.15).toLocaleString()} trials projected (Week +2)` : `Trend reversal = ${Math.floor(metrics.totalTrials * 0.2).toLocaleString()} trial recovery potential`
                });
            }

            // Render insights with priority sorting
            insights.sort((a, b) => {
                const priority = { high: 3, medium: 2, low: 1 };
                return priority[b.priority] - priority[a.priority];
            });

            container.innerHTML = `
                <div style="background: var(--gray-50); padding: 1rem; border-radius: var(--radius-md); margin-bottom: 1rem;">
                    <strong>üìä Analysis Summary:</strong> Generated ${insights.length} executive insights ‚Ä¢
                    ${insights.filter(i => i.priority === 'high').length} high priority ‚Ä¢
                    ${insights.filter(i => i.priority === 'medium').length} medium priority ‚Ä¢
                    Total addressable opportunity: ${Math.floor(metrics.totalTrials * 0.35).toLocaleString()} trials
                </div>
            ` + insights.map((insight, idx) => `
                <div class="insight-card ${insight.priority}">
                    <span class="insight-badge ${insight.priority}">${insight.priority.toUpperCase()} PRIORITY</span>
                    <div class="insight-title">${idx + 1}. ${insight.title}</div>
                    <div class="insight-analysis">${insight.analysis}</div>
                    <div class="insight-recommendation">
                        ${insight.recommendation}
                    </div>
                    ${insight.impact ? `<div style="margin-top: 0.75rem; padding: 0.5rem; background: var(--gray-900); color: white; border-radius: var(--radius-sm); font-size: 0.875rem;"><strong>üíº Business Impact:</strong> ${insight.impact}</div>` : ''}
                </div>
            `).join('');
        }

        // ========== SETTINGS ==========
        function showSettings() {
            alert('‚öôÔ∏è Dashboard Settings\n\n' +
                  '‚úÖ Executive Insights: Enabled (No API required)\n' +
                  '‚úÖ Data Storage: IndexedDB (Browser-based)\n' +
                  '‚úÖ Historical Tracking: Automatic\n\n' +
                  'All features are active and working!\n\n' +
                  'To clear all data:\n' +
                  'Open browser console (F12) and run:\n' +
                  'indexedDB.deleteDatabase("STAGEDashboard");');
        }

        // ========== INITIALIZATION ==========
        document.addEventListener('DOMContentLoaded', async () => {
            new UploadHandler();

            // Market selector
            document.querySelectorAll('.market-btn').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    document.querySelectorAll('.market-btn').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    const market = e.target.dataset.market;
                    stateManager.setState('currentMarket', market);
                    const marketData = await db.markets.get(market);
                    if (marketData) {
                        stateManager.setState(`markets.${market}`, marketData.data);
                        DashboardRenderer.render();
                    } else {
                        DashboardRenderer.render();
                    }
                });
            });

            // Tab navigation
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                    e.target.classList.add('active');
                    const tab = e.target.dataset.tab;
                    document.getElementById(`tab-${tab}`).classList.add('active');
                    stateManager.setState('currentTab', tab);
                    DashboardRenderer.render();
                    if (tab === 'insights') generateInsights();
                });
            });

            // Load initial data
            const currentMarket = stateManager.getState('currentMarket');
            const marketData = await db.markets.get(currentMarket);
            if (marketData) {
                stateManager.setState(`markets.${currentMarket}`, marketData.data);
                DashboardRenderer.render();
            }

            console.log('‚úÖ STAGE Dashboard v2.0 Initialized - Sprint 2 Complete');
        });
    </script>
</body>
</html>